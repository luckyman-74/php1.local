<html>
<head>
    <title>Классы и объекты</title>
</head>
<body>
<?php
//Классы и объекты
//Название класса принято писать с большой буквы.
//Определение класса:
class Table
{
    public $color;
    public $legs;
}

//Для создания объекта с нужным классом применяется слово "new".
//Для доступа к свойсвам класса используется кострукция "->".
//Знак "$" пишется только один !
$table1 = new Table;
$table1->color = 'black';
$table1->legs = 4;
var_dump($table1);
echo '<br>';
echo '<p>Цвет стола 1: ' . $table1->color . '<br>' . 'Количество ножек стола 1: ' . $table1->legs . '</p>';

$table2 = new Table;
$table2->color = 'white';
$table2->legs = 3;
var_dump($table2);
echo '<br>';
echo '<p>Цвет стола 2: ' . $table2->color . '<br>' . 'Количество ножек стола 2: ' . $table2->legs . '</p>';

//Метод-это функция определенная в классе и связанная с объектами этого класса.
//Внутри метода мы можем обращаться к свойствам этого объекта с помощью псевдопеременной "this".
//Сам же метод вызывается через "->".
//"Сбор" свойств и методов в классе называется "ИНКАПСУЛЯЦИЯ".

class Table2
{
    public $color;
    public $legs;

    public function show()
    {
        echo 'Привет я стол !' . '<br>';
        echo 'О ' . $this->legs . ' ' . 'ногах,' . ' ' . $this->color . ' ' . 'цвета.';
        //echo внутри функции просто в учебных целях.Вообще, в функции недопустимы побочные эффекты.
        //Функция должна только возвращать результат ее работы.
    }
}

$table3 = new Table2;
$table3->color = 'синего';
$table3->legs = 5;

$table3->show();

//Модификатор доступа. Public-свойство доступно из вне. Protected - доступно только внутри класса.
/**НАСЛЕДОВАНИЕ.*/
//Это передача по наследству свойств и методов.
//Например есть разная мебель. Столы,стулья и шкафы = МЕБЕЛЬ.
//Что у всей мебели общего ? Материал и цвет (например), т.е. 2 свойства общее у всей мебели.
//Опишем класс:
class Item
{
    public $color;
    public $material;

    public function showColor()
    {
        echo '<p>Мой цвет = ' . $this->color . '</p>';
    }
}

//А что общего у каждого конкретного класса мебели ? У класса столов, стульев и шкафов ?
//У столов - количество ножек. Опишем класс столов унаследовав свойства основного класса Item:

class Mytable extends Item
{
    public $legs;
}

//Таким образом мы получили класс Table со свойствами color, material и legs.Первые 2 мы унаследовали от класса Item.
$table = new Mytable;
$table->color = 'серый';
$table->legs = 6;
$table->material = 'древесина';
$table->showColor();
var_dump($table);
//Наследование реализуется указанием класса-потомка у наследника через ключевое слово extends (расширение).
// Т.е. мы "расширяем" диапазон свойств класса, добавляя новые специфичные свойства в класс-потомок.
//Потомок может быть только один !
//Классы-потомки получают в наследство все свойства и методы классов-родителей.

//Методы переданные в класс-потомок от класса родителя можно изменять, описав их заново с тем же именем, или добавить новый метод.
//Переписать(видоизменить) метод полученный от родителя с тем же именем называют "Перекрыть" метод.
//Также, можно что-то добавить в родительский метод. Например вот так:
/**
 * class Table extends Item
 * {
 * public=$legs;
 * public function showColor(){
 * echo 'я потомок класса Item !';
 * parent::showColor();
 * }
 * }
 */
// Таким образом, мы добавили в метод вывод эхо, а после этого, командой perent::method() запустили в работу метод родительского класса.
// Команда parent::method() запускает код метода описанного в родительском классе.

/** КОНСТРУКТОР */
//Конструктор - это метод, который выполняется АВТОМАТИЧЕСКИ при создании объекта класса.
//Метод - конструктор всегда называется "__construct".

class Stol
{
    protected $color; //для примера выведем свойство цвет из интерфейса, т.е. защитим его. Из вне теперь нет прямого доступа к ниму.
    public $legs;

    public function __construct($color)
    {
        $this->color = $color;
    }

    public function show()
    {
        echo '<p>Я стол. Мой цвет: ' . $this->color . '</p>';
    }
}

$table = new Stol ('Зеленый');
$table->show();

//Класс - это тип объектов.
//Все объекты в PHP имеют тип objects. Это легко проверить: (оператор gettype();)
class SomeClass
{
}

$obj = new SomeClass;
echo gettype($obj) . '<br>'; //object

class User
{
}

//Однако, каждый класс можно рассматривать тоже как некий тип данных!: (оператор get_class();)
$user = new User;
echo get_class($user); // User. Т.е. возвражает имя класса объекта User.
//В PHP существует спец.оператор, который позволяет определить является ли объект объектом заданного класса:
if ($obj instanceof SomeClass) {
    echo '<br> Да, объект $obj является объектом класса SomeClass !';
}
//Примечательно, что такая проверка даст 'true',если имя указанного класса будет одним из ПРЕДКОВ класса данного объекта.
//Есть еще одно отличное применение классам как типам. Это натывается 'тайп хинтинг':
/**function sendmMail (User $user,$msg)
 * {//...}
 * $user = new User (...);
 * sendmMail($user,'hello!');*/
//Вызов такой функции будет успешен, если аргумент $user-объект класса User (или класса-наследника).
//Если же мы попытаемся передать что-то другое - возникнет фатальная ошибка !
//Тайн-хинтинг позволяет нам контролировать ход выполнения программы и использовать принципы ООП.

//Пример. Есть класс Users(все пользователи) и класс-наследник Admins(администраторы):
class Users
{
public $email;
public $sex;
}

class Admins extends Users
{
}

function sendMail(Users $user, $message) //Функция отправки письма ожидает, что пользователь будет являться объектом класса User.
{
    echo '<br>Письмо: ' . $message . ' отправлено на адрес '.$user->email;
}

$user = new Admins; //Класс Admins - наследник класса Users, админы тоже юзеры, поэтому функция sendMail() отработает верно.
$user->email = '8661319@mail.ru'; //можем стазу передать значение свойства $email...
sendMail($user, 'Hello, Admin !');//Вызываем функцию и передаем параметры.
//В таких случаях всегда нужно передавать целиком объект-пользователя, т.к. в фунции может понадобится не только e-mail,
//но и другие его параметры, например имя, пол, возраст и т.п. Таким образом мы будем иметь в доступе все свойства объекта.
?>

</body>
</html>